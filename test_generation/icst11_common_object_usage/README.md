# Exploiting Common Object Usage in Test Case Generation

### Authors: Gordon Fraser, Andreas Zeller
### Link: https://ieeexplore.ieee.org/document/5770597

## Abstract
This study aims to mine common object usage patterns from manally written code to generate similar code to make generated tests more readable and avoid violations of implicit pre-conditions.

## Background
### Challenges for Test Generation
Existing automatic test generation techniques suffer from two major problems: 1. generated tests are often very long and hard to understand (poor readablity); 2. methods can have *implicit preconditions* which the developer might be aware but the test case generation tool is not.

### Usage Models
Markov chain usage models for statistical testing. 
This study: Marko usage models + search-based testing technique.

## Approach
### Common Object Usage Analysis
- Use JADET to mine object usage information from bytecode
- Temporal property: an ordered pair of events a and b associated with the same object. Events: 
    - Method call with the object being used as **callee** or **argument**
    - Method call with the object being the value that was **returned**
    - Field access
    
    Temporal property T = (A<sub>1</sub>, A<sub>2</sub>), A<sub>i</sub> = (C, m, p). C: class, m: method, p: parameters.
- Class Usage Models
    - vertex: method (in one class)
    - edge: probability of executing v2 after v1
    - U<sub>c</sub> = (V, E, P)
- API Usage Models
    - superset of all the class models
    - vertex: method (in all classes)
    - edge: probability of executing v2 after v1
    - M<sub>c</sub> = (V, E<sub>c</sub>, E<sub>p</sub>, P<sub>c</sub>, P<sub>p</sub>)
- Test Case Generation Using API Usage Model
    - When an object is required in test generation and no suitable object exists, then an object can be generated by inserting a method call that is an outgoing edge for the parameter in E<sub>p</sub>.
    - Intergrating Usage Information  into Search-based Testing. We can determine fitness of current population to guide the generation of offsprings.
    - Mutation: three main types of mutation operators: Insertion, Change, Deletion.

## Evaluation & Conclution
1. Larger variety in usage examples -> higher resulting coverage
2. Test cases derived from common usage are shorter than test cases generated without usage information (better readability)
3. Testers can balance readability and exploration by shifting probability of common/uncommon usage.
4. Test cases based on common usage raise fewer exceptions and violate fewer implicit preconditions.